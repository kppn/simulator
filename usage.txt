simsim  - State in multi-protocol simulator

概要
  状態 - イベント - アクション型の通信ソフト用シミュレータの
  フレームワークです。
  複数の通信相手(ピア)と、それぞれ指定したプロトコルで通信します。
  プロトコルは自分で作ります。

  RubyでDSLとして作られており、あらゆる記述はRubyプログラムとして
  動作するため、Rubyの能力内なら何でもできます。


#=============================================================
# チュートリアル
#=============================================================

  さっそく作ってみましょう。

  プロトコル
    ここでは、XProtoという名前の簡単なプロトコルと、そのプロトコルで
    通信するXServer/XClientというノードを想定します。あなたはXServer
    ソフトを作っており、それをテストするためにXClientをシミュレートしたい、
    としましょう。

    XProtoの定義は次の通りです。

      プロトコルスタック
        IP - UDP - XProto

      XProto構文
        +---------+----------+
        | version | value    |
        +---------+----------+

          version: 1バイト。符号なし整数
          value: 1バイト。符号なし整数

    versionは0のみ定義されており、それ以外の値を受信したら破棄します。
    XServerは受信したvalueを2倍にしてXClientへ送信します。


    まず、あなたはXProtoを処理するクラスを作る必要があります。

      class XProto
        attr_accessor :version, :value

        def self.from_bytes(byte_str)
          xproto = self.new
          xproto.version = byte_str[0].unpack('C')
          xproto.value   = byte_str[1].unpack('C')
          xproto
        end
      end

      Tips:  def self.xxx というのは、Rubyでクラスメソッドを定義
             する構文です (より正確に言うと、XProtoのシングルトン
             クラスへメソッドを定義します)。

      Tips:  unpack('C')は、符号なし8ビット整数へアンパックする
             メソッドです。詳しくは以下を参照。
               https://docs.ruby-lang.org/ja/latest/doc/pack_template.html

    from_bytesは受信したバイト文字列からクラスのインスタンスを作成する
    ジェネレータです。simsimはこの名前のクラスメソッドがあることを期待
    します。例えば、次のように利用します。
      xproto_instance = XProto.from_bytes("\x00\xab")

  準備と起動
    作成したプロトコル、シナリオ、コンフィグのファイルを準備します。

    simsimのディレクトリ中で、以下のファイルを用意しましょう(ファ
    イルの場所は任意です)
      config.rb
      scenario/tutorial.rb
      protocol/xproto.rb


    コンフィグに必要な事項を記述します。
      config.rb
      -----------------------------------
      log 'XProto Simulator'

      require_relative '/your/path/to/simsim/protocol/xproto'

      peer '1.1.1.1:1000', '2.2.2.2:2000', XProto
      -----------------------------------

    logは、シナリオで使う@loggerのテンプレート文字列です。これは指定
    しなくても構いません。
    require_relativeで、あなたが作ったプロトコルのスクリプトを読み込み
    ます。前述のクラスをこのファイルに記載しましょう。
    peerでは、simsim側、ピア側のIPとポート番号、及び利用するプロコトルの
    クラスを指定します。IPとポート番号は環境によって変更してください。

    次にシナリオを記述します。
    まずは、起動後にログを出すだけの簡単なシナリオを見てみましょう。

      scenario/tutorial.rb
      -----------------------------------
      state :initial do
        in_action {
          @loggger.info "scenario started"
        }
      end
      -----------------------------------

    ここまでで必要な準備は完了です。
    では実際に動かしてみましょう。simsimのディレクトリの中で、以下の
    コマンドを実行してください。

      ./simsim config.rb scenario/tutorial.rb

    "scenario started"のログが表示されたでしょうか？

    以降では、実際に信号を送受信するシナリオを記述してみます。

  シナリオ
    信号を一回だけ送信し、受信した応答を表示するシナリオを書いて見ま
    しょう。

      state :initial do
        in_action {
          transit :main   # :main 状態へ遷移
        }
      end

      state :main do
        in_action {
          send "\x00\x01"   # version:0, value:1 で送信する
        }

        # version:0の信号を受信したらこのイベントが発生
        receive(->{ @sig.version == 0 }) {
          if @sig.value == 2
            puts "success"
          else
            puts "value is wrong!!!"
          end
        }

        # それ以外(versionが0ではない)の信号を受信したらこのイベントが発生
        receive(->{true}) {
          puts "undefiend version #{@sig.version} received !!!"
        }
      end

    シナリオにはエントリポイントとなる状態とアクションが必要です。
    simsimはシナリオを開始すると:initial状態のin_actionイベントを
    発火します。
    in_actionは、その状態へ遷移した時に発火するイベントです。
    transitは状態を遷移する命令です。ここではtransit命令でユーザが
    定義した:main状態へ遷移させています。

    :main状態にもin_actionイベントが定義されているため、状態遷移したら
    すぐにそのアクションが実行されます。ここではsend命令で信号を送信して
    います。

    以降のreceiveイベントは、XServerからの信号受信を待っています。
    最初のreceiveイベントを詳しく見てみましょう。

      receive(->{ @sig.version == 0 })

    receiveイベントには、そのイベントが発火するマッチ条件を指定します。
    受信した信号のバージョンが0ならこのイベントにマッチします。
    構文は receive(->{ 条件式 }) です。

      Tips. 条件式はRubyのif文で真/偽となるものなら何でも書けます。
            Rubyではnilまたはfalseは偽、それ以外は全て真です。
            ==メソッドはtrue/falseを返します。

      Tips. ->{}はなんでしょうか。これはRubyで第一級関数を生成する
            構文です。より詳しく知りたい人は『Ruby lambda』でググりま
            しょう。

    @sigとは何でしょうか。simsimは信号を受信すると、その信号を
    XProto.from_bytesを使ってインスタンス化し、@sigにセットします。
    これによって、マッチ条件で既にデコードされたXProtoインスタンスの
    メソッドを利用することができます。

    イベントにマッチした後のアクションは自由に記述できます。
    ここでは、受信したvalueが、送信したものの2倍になっているかを確認し、
    結果を表示しています。

    simsimは複数のイベント条件にマッチする場合、最初にマッチしたもの
    だけ発火します。イベントの順序に注意してください。->{true}は
    どのような信号を受信してもマッチするため、これより後に定義した
    イベントは決して発火しません。

    このシナリオで、サーバからの応答を受信しアクションを実行した後は
    どうなるでしょうか。
    シナリオは次の信号の受信を待ち続けますが、XProtoはクライアント-
    サーバ型のプロトコルですから、次のイベントの契機がありません。
    ここで終わりです。

    それでは次に、ユーザが任意の時点で信号を送信するシナリオを作成して
    みましょう。

  コントロールイベント
    コントロールイベントは、外部からの指示によって発火するイベント
    です。次のように定義します。

      control(:do_send)

    これを利用したシナリオを以下に示します。

      state :initial do
        control(:do_send) {
          send "\x00\x00"
        }

        receive(->{true}) {
          puts "any signal received"
        }
      end

    simsimは起動時にコントロールイベントを受信するためのUDPソケットを
    開きます。
    同梱のcmdユーティリティを使ってコントロールを発行する事ができます。
      ./cmd 127.0.0.1:53689 control do_send
    シナリオはコントロールイベントの名前がマッチすると、そのイベントを
    発火します。


  番号指定コントロールイベント
    コントロールイベントでは、条件に番号を指定することができます。

      state :initial do
        control(:do_send, 1) {
          send "\x00\x01"
        }

        control(:do_send, 2) {
          send "\x00\x02"
        }
      end

    cmdユーティリティで、番号を指定してコントロールを実行します。
      ./cmd 127.0.0.1:53689 control do_send 2
    コントロール番号は0から255の間です。

    コントロールイベントは厳密にマッチされます。例えば、番号無しで
    コマンドを実行した場合、条件に番号が無ければマッチしません。

      state :initial do
        control(:do_send, 1) {
          send "\x00\x00"
        }
      }

      ./cmd 127.0.0.1:53689 control do_send
      # アンマッチ

    逆も同様です。

    cmdユーティリティの最初の引数(127.0.0.1:53689)は、simsimが
    コマンド用に開いているUDPソケットです。ポート番号は毎回異なります。
    cmdを使う前にそれを調べるのは面倒です。simsimは開いたソケットの
    情報をevent.sockファイルに保存しています。同じホストでcmdを使う
    なら、そのファイルを指定して実行する事ができます。
      ./cmd event.sock control do_send

  タイマーイベント
    シナリオ中でタイマーを起動し、タイマー満了時にイベントを発火する
    ことができます。
    定期的に信号を送信するシナリオを書いてみましょう。

      state :initial do
        in_action {
          start_timer :do_send, 2.5
        }

        expire(:do_send) {
          send "\x00\x00"

          start_timer :do_send, 3
        }
      end

     このシナリオでは、起動してから2.5秒後に信号を送信し、以降は3秒毎に
     信号を送信し続けます。

     start_timer命令で名前と時間を指定してタイマーを起動し、そのタイマーが
     満了するとexpireイベントが発火します。ここでは、3秒毎に信号を送信する
     ため、expireイベントのアクション中で再びタイマーを起動しています。

     タイマーはスレッドとsleepで実装されています。満了時刻が同じと予測される
     複数のタイマーが動作している場合、どちらのイベント契機が先に発生するかは
     予測できません。

     単にシナリオの動作を遅延させたいなら、アクション中でKernel.sleepを直接
     使用することもできます(あらゆる処理は純粋なRubyプログラムであることを思い
     出してください)。しかし、その場合はsleepが満了するまでシナリオ処理全体が
     止まる事に注意しましょう。アクションがsleepで止まっていてもタイマーは動き
     続けるため、もしタイマーとアクション中のsleepを同時に使用し、sleep中に
     タイマーが満了していたら、sleep復帰の直後にイベント契機が発生します。
     一般的には、タイマーとsleepが同時に動くシナリオは避けたほうが良いでしょう。
     
     stop_timerは動作中のタイマーを破棄します。
     典型的な使い方は、応答のタイムアウトのためにタイマーを起動し、その後
     正常に応答を受信した場合です。この場合、タイムアウトのイベント契機が
     発生しないようタイマーを停止しなければなりません。


 変数を利用する
   シナリオの中で変数を利用してみましょう。

   ここまでの説明では、送信する信号の内容を文字列として直接記述していました。
   シナリオ中でもXProtoクラスを利用して信号を作成できたら便利です。まずは
   XProtoクラスをバイナリへエンコーディング出来るようにクラスを拡張します。

      class XProto
        # ...
        def encode
          [version, value].pack('CC')
        end
      end

    それでは、シナリオ中で変数を定義し、それを使って信号を送信してみます。
    少し複雑ですが、ここではvalueをインクリメントしながら定期的に信号を
    送信してみます。


      state :initial do
        @val = 1

        @my_signal = XProto.new
        @my_signal.version = 0
        @my_signal.value = @val

        in_action {
          start_timer :do_send, 1
        }

        expire(:do_send) {
          @my_signal.value = @val
          send @my_signal.encode
          @val += 1

          start_timer :do_send, 1
        }
      end

    :initialの直下で、@my_signalという変数にXProtoクラスのインス
    タンスを設定しています。また@valでvalueに設定する値を変数として
    管理します。
    @で始まる名前の変数は、stateの中ならどこでも参照することができ
    ます。
    expireイベントのアクションでは、先ほど作ったencodeメソッドで
    バイナリ文字列を生成し、送信しています。

    変数を使う目的は、@my_signalのように送信する信号を予め定義して
    おくことです。しかしシナリオの先頭にこのような記述が続くのは見苦
    しいと思いませんか？simsimでは予め処理されるものをdefineの中に
    記述することができます。

      state :initial do
        @val = 1
        # 省略
      end

      define do
        @my_signal = XProto.new
        @my_signal.version = 0
      end

    @valをdefineに移すのはやめたほうが良いでしょう。この変数は
    シナリオ中で変更されるため、stateの中で定義したほうが読む人に
    意図が伝わりやすいからです。

    ここで各処理の実行順序を整理しておきましょう。
      1. state/defineの直下。記載した順序で実行される
      2. イベントが発生すると、そのイベントのアクションの中

    stateの直下もシナリオ開始前に実行される事に注意してください。
    例えば、次の(恣意的な)シナリオは誤りです。

      state :initial do
        puts @message  # defineがまだ実行されていないため@messageは未定義
      end

      define do
        @message = "hello"
      end


  これでチュートリアルは終了です。

  イベント駆動型のプログラムを書くのはしんどい仕事です。simsimが
  少しでもあなたの仕事を楽にする事を願います。


#=============================================================
# シナリオ構文
#=============================================================

状態
  state 状態名 do
  end

    状態名: Symbol

  状態を定義します。
  シナリオ開始時は:initialという名前の状態に遷移します。:initial状態では
  必ずin_actionを定義して下さい。
  無名の状態は作れません。

  doの書き忘れに注意してください。どうしても忘れる人はdo?endの代わりに
  {}を使って下さい。


イベント
  in_action {}
    その状態へ遷移した時に発火します。

  out_action {}
    transitで状態遷移する時に発火します。
    同じ状態へ遷移する場合でも発火します。

  receive(->{条件}) {}
    信号を受信し、条件が真の時に発火します。
    条件に常に真の式を書くと、あらゆる信号受信でイベントが発火します。

  receive(->{条件}, ピア名) {}
      ピア名: Symbol。コンフィグで指定したピア名。

    指定したピアからの信号を受信し、条件が真の時に発火します。
    マルチピアのシナリオを記述する場合に利用します。

  expire(タイマー名) {}
      タイマー名: Symbol

    そのタイマー名のタイマーが満了した時に発火します。

  control(コントロール名 [, 番号]) {}
      コントロール名: Symbol
      番号: 0?255

    外部からのコントロールが実行された時に発火します。
    番号はオプションです。番号指定の有り/無しは厳密にマッチします。


アクション命令
  transit 状態名
      状態名: Symbol

    状態を遷移します。
    遷移前には現在の状態のout_actionを発火し、遷移後は遷移した
    状態のin_actionを発火します。

  send 信号 [, ピア名]
      信号: 文字列(Stringクラスのインスタンス)
      ピア名: 送信先のピア名。コンフィグで設定されたもの。

    ピアに信号を送信します。
    ピア名が省略された場合はプライマリピアへ送信し、指定された場合は
    そのピアへ送信します。

  start_timer タイマー名, 時間
      タイマー名: Symbol
      時間: 数値型(秒) (Integer/Float)

    タイマーを作成し開始します。
    時間は1や2.5のように秒単位で指定します。
    タイマーは1回限りのオブジェクトです。一定周期で繰り返したい
    場合、同じ名前のタイマーを繰り返し作成してください。
    あるタイマー名のタイマーが動作中に同じ名前のタイマーを開始した
    場合、以前のタイマーは破棄されます。

    (開発) start_timerは実行されるとすぐにタイマー名を持った
          Threadインスタンスを作成し、指定秒だけsleepしたあとに
          タイマーイベントのコントロールパケットを自身へ送信します。

  stop_timer タイマー名
      タイマー名: Symbol
    
    動作中のタイマーを破棄します。
    指定のタイマー名のタイマーが無い場合は何もしません。


#=============================================================
# 予約変数
#=============================================================

@logger
  Loggerクラスのインスタンスです。
  デフォルトでは、logdev=STDIO, level=Logger:DEBUGに設定されています。

  シナリオ中でログを出したい場合、この変数で指定する事ができます。
    @logger.info "Signal received!!"
  このLoggerインスタンスには、simsimのシステムログも出力されます。
  自分自身のログが欲しい場合、Loggerクラス(やそれに類する何か)をシナリオで
  作成し利用してください。
    例) @mylog = Logger.new(File.open("mylog.txt", "w"))

@decode_params
  定義するとsimsimがfrom_bytesを呼び出すときに引数へ追加されます。
  Array型で指定します。
  例えば、暗号化されたプロトコルでは、次のように鍵を指定してfrom_bytesを
  呼び出す必要があるでしょう。
    instance = EncryptedProto.from_bytes(enc_bytes, key)

  simsimは次のようにfrom_bytesを呼び出します。
    EncryptedProto.from_bytes(enc_bytes, *@decode_params)


#=============================================================
# マルチピア・マルチプロトコル
#=============================================================

概要
  simsimは1つのシナリオで複数のピアとの通信をシミュレートすることができます。
  各ピアのプロトコルは異なっていても構いません。


例
  典型的な使い方として、プロトコル・スタックの仲介があります。

  MultiProtoというプロトコルを例にしてみましょう。
  このプロトコルのペイロードには、他のプロトコルのデータが入っています。

  MultiProto構文
    +----------+----------+
    | proto    | payload  |
    +----------+----------+

      proto: ペイロードのプロトコル。0ならYProto、1ならZProto
      payload: それぞれのプロトコルのデータ

  ノードの接続は次の通りです。
    +---------------+      +--------+       +------------+
    | YProto Client |------|        |       |            |
    +---------------+      |        |       | MultiProto |
                           | simsim |-------| Server     |
    +---------------+      |        |       |            |
    | ZProto Client |------|        |       |            |
    +---------------+      +--------+       +------------+

  MultiProto/YProto/ZProtoのクラスは作成済みとします。

  まずはコンフィグを記載します。
  peerでピア名を書くと、シナリオ中のイベント条件、send命令でその名前を
  指定できるようになります。

    # プライマリピア
    peer "1.1.1.1:1000", "2.2.2.2:2000", MultiProto

    # YProto clientのピア
    peer :yproto_client, "11.11.11.11:11112", "22.22.22.22:22222", YProto

    # ZProto clientのピア
    peer :zproto_client, "11.11.11.11:11113", "33.33.33.33:33333", ZProto


  MultiProtoを処理する以下のシナリオでは、単純に各プロトコルのデータを
  仲介するものとします。

    state :initial do
      @multi_proto = MultiProto.new

      # Multi Proto Serverからprotoが0の信号を受信。
      receive(->{ @sig.proto == 0 }) {
        # ペイロードをYProto Clientへ送信する。
        send :yproto_client, @sig.payload.encode
      }

      # Multi Proto Serverからprotoが1の信号を受信。
      receive(->{ @sig.proto == 1 }) {
        # ペイロードをYProto Clientへ送信する。
        send :zproto_client, @sig.payload.encode
      }

      # YProto Clientから受信。
      receive(->{ true }, :yproto_client) {
        @multi_proto.proto = 0
        @multi_proto.payload = @sig.encode
        send @multi_proto.encode
      }

      # ZProto Clientから受信。
      receive(->{ true }, :zproto_client) {
        @multi_proto.proto = 1
        @multi_proto.payload = @sig.encode
        send @multi_proto.encode
      }
    end

  receiveの引数にピア名が指定されていることに注目してください。
  このように指定されたreceiveイベントは、そのピアからの信号受信でのみ
  マッチングされます。
  また、sendではどのピアに送信するかを第1引数で指定することができます。
  省略した場合はプライマリピアです。


その他の使い方
  もちろん、前述の例と異なり、単純に複数のピアと通信する目的でもこの
  機能を利用できます。
  例えば、3つのノードが通信するシステムを考えましょう。それぞれの
  プロトコルは異なるものとします。

       PeerA          PeerB        PeerC
         | 1) Request  |             |
         |------------>|             |
         |             | 2) Request  |
         |             |------------>|
         |             | 3) Response |
         |             |<------------|
         | 4) Response |             |
         |<------------|             |
         | 5) Request                |
         |-------------------------->|
         |               6) Response |
         |<--------------------------|

  PeerAをシミュレートする場合、1),4)のやりとりの結果を考慮して
  PeerCへの5)リクエストの内容を決める必要があります。

  PeerB向け、PeerC向けにそれぞれsimsimを起動し、2つのsimsim間で
  結果を通知し合う、という方法も考えられるでしょう。しかし、明らかに
  1つのシナリオで記述できた方が効率的です。

  このような状況を考慮し、simsimはマルチピア・マルチプロトコル型で
  設計されました。


#=============================================================
# Q&A
#=============================================================

Q TCPは使えないの？
   A そのうち作ります。

     あなたの開発への参加を心待ちにしています。

Q 自分で関数を定義したい
   A 次のようにしてください。
       state :initial do
         in_action {
           my_method 1
         }
       end

       define
         class.define_method('my_method') do |arg|
           # ...
         end
       end

     もしあなたがRubyistなら次の一言で理解できるでしょう。
     「simsimは全てをSimulatorクラスの1つのインスタンスの中で処理する」

Q アクションの途中で処理をやめたい
    A nextを使って下さい。

Q ループって使える？
    A 使えます。
      「Ruby loop」でググりましょう (forやwhileを使う人は嫌いです)。

Q 変数は @hoge といったものしか無いの？
    A ローカル変数は自由に利用できます。アクション内に閉じて使うならローカル
      変数の方が適切でしょう。
      クラス変数(@@hoge)は、自分が何をしているのか解っている場合のみ利用
      下さい。

Q 1つのシナリオで複数のクライアントを作って負荷テストをやりたいんだけど
    A (今のところ)できません。そのうち作ります。

      simsimはマルチプロトコル型のフレームワークなので、各クライアントの
      識別とセッション管理の方法をプロトコルクラスの側で持つ必要があり
      ますが、方式とAPIをまだ決定していません。

      あなたの開発への参加を心待ちにしています。

Q 外部のライブラリ(gem)を使いたい
    A requireでご自由にどうぞ。
      記載場所はconfigの中が良いでしょう。

Q 複数の受信信号を保存しておき、後で使いたい
    A 「X回前の信号」といった用途ならArrayを利用すると良いでしょう。
      FIFOならQueueやSizedQueueがぴったりです。
      信号にマークをつけて保存するならHashに入れるのが適切です。

Q 受信した生のバイナリ文字列を参照したい
    A simsimは必ずfrom_bytesでインスタンス化します。
      あなたのプロトコルクラスのfrom_bytesで生データを保存し、取り出す
      ためのメソッドを追加して下さい。
      プロトコル自体が真にバイナリ文字列であるなら、Stringクラスをモンキー
      パッチしてfrom_bytesを定義するのが簡単です。

Q Rubyでバイナリって扱い辛くない？
    A はい。
      BinDataというgemをご紹介します。
        https://github.com/dmendel/bindata

Q 自動テストのように複数のテストを一気に実行したい
    A シナリオを変えてsimsimを何度も起動すればよいでしょう。
      シナリオがそのテストのOK/NGを判定できる時点になったらexitで
      終了させ、起動側でステータスコードを判定するという方法があり
      ます。

      しかし、あなたが作っている通信系ソフトの自動テストを行いたいなら、
      実際の通信を行わずともテストできるアーキテクチャにするのが最良の
      手段です(通信シミュレータを使ったテストは必要悪です。開発工程に
      おいてテストの工数は5割を超えることを思い出しましょう)。

Q 複数のシナリオで変数を共有したい
    A simsimは1つのシナリオのみ動作します(ただし、部品化された複数の
      ファイルを読み込む事はできます。状態名が重複しないように注意
      してください)。
      今のところ、マルチピア機能を使って複数のsimsimプロセス間で通信
      させる手段が採れます。

#=============================================================
# その他、どうでも良いこと
#=============================================================

Q どうしてこんなもの作った？
    A 私が通信ソフト業界の人間だからです。
      某日本大手電気会社のSH○FTというシミュレータを長らく触っていましたが、
      それへのアンチテーゼの意味もあります。
        ・シナリオでは汎用言語レベルのプログラミングがしたい。
        ・シナリオのために専用言語を作ると機能が限定される。機能を増やす
          にはシミュレータ本体の改造が避け得ず、時間が掛かる。
        ・強力な言語なら、その言語のDSLとしてシナリオを書けるのではないか。
        ・強力な言語なら、低コストでシナリオ型のシミュレータを書けるのでは
          ないか (simsim本体はわずか350行です)。

Q どうしてRuby？
    A 開発前にいくつか候補がありました。
        Scala, Python, Ruby
        C/C++, D, JS, Lisp, Elixir
      PythonはDSLが書きづらいので候補から外れました。Scalaは良い選択肢
      だったのですが、(おそらく)ユーザの学習コストが大きいため外れました。
      その他は
        C/C++: 時代遅れ
        D: 思ったより流行らず残念
        JS: ソケット通信がやり辛い
        Lisp: 私は好きですよ、ええ
        Elixir: ユーザを関数脳へ染めるのが難しい？
      よってRubyにしました。

Q 性能的にはどうなの？
    A 性能は度外視しています。
      ユーザがいないうちは性能を気にしても意味がありません。高性能に
      するならよりコストを掛けて、おそらく実装言語から見直す必要が
      あります。
      あなたの開発への参加を心待ちにしています。

Q 状態-イベント-アクションを表のように定義したい
    A 方法はありますが、教えません。
      欲しいシミュレータを自分で作って下さい。
      あなたが真のRubyistなら、simsimをハックして方法を見つけて下さい
      (しかし、けっしてあなたの『工夫』を他の人に広めないように！)。

Q XXというプロトコルのシミュレータが欲しい。作ってくれない？
    A あなたには2つの選択肢があります。
        1. 自分で作る (推奨)
        2. 私の口座にお金を振り込む

      もしあなたが、この業界の人でありながらソフトウェアがタダで手に入ると
      思っているなら、
      「俺はお前のママじゃねーんだよ、富士の樹海へでも行って(以下略)」

Q ほげ？
    A ふが。
      あなたの開発への参加を心待ちにしています。


Regards.
EOF
